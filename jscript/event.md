[< К содержанию](../readme.md)
***
# события

[Смотреть] выполнение примеров
***

> **Событие** — это сигнал от браузера о том, что что-то произошло.

## Наиболее популярные события:

1. **мышь**:
    * *click* — происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании),
    * *mousemove* — при движении мыши,
    * *contextmenu* — происходит, когда кликнули на элемент правой кнопкой мыши,
    * *mousedown / mouseup* — когда нажали / отжали кнопку мыши на элементе,
    *mouseover / mouseout — когда мышь наводится на / покидает элемент,
2. **элементы управления**:
    * *submit* — пользователь отправил форму `<form>`,
    * *input* — пользователь изменил текст в `<input>`,
3. **клавиатура**:
    * *keydown и keyup* — когда пользователь нажимает / отпускает клавишу,
4. *документ*:
    * *DOMContentLoaded* — когда HTML загружен и обработан,
5. **CSS**:
    * *transitionend* — когда CSS-переход завершён.

## Обработка события

> **Обработчик** — это функция, которая сработает, как только событие произошло. 

> **Назначение обработчика через использование атрибута**

        `<h2 onclick="console.log('Это тот блок')">Тест консоли</h2>`

> **Назначение обработчика через свойство**

        `<h2 id="testTextField">Тест консоли</h2>`

        `const  testTextField = document.querySelector('#testTextField');
        testTextField.onclick = function() {
        // тело обработчика
        console.log('Это тот блок');
        // конец тела обработчика
        }`

или

        `document.querySelector('#testTextField').onclick = function() {
          // тело обработчика
          console.log('Это тот блок');
          // конец тела обработчика
        }`

Удалить такой обработчик можно:

        `document.querySelector('#testTextField').onclick = null;`


> *У этого метода (как и у предыдущего) существует один серьёзный недостаток — нельзя назначить более одного обработчика на событие таким образом. Например, текст в поле ввода проверяется на валидность через один обработчик при событии input, а через другой обработчик — отправляется запрос на сервер. В этом случае, когда назначается на поле ввода второй обработчик, первый затирается.*

> **Назначение обработчика через addEventListener**

> Наиболее современный способ назначения обработчика — назначение через метод `addEventListener`.

        `element.addEventListener(event, handler);
        // element - элемент, событие которого отслеживается
        // event - событие
        // handler - обработчик`

Этот способ назначения обработчика наиболее предпочтителен, так как он лишён основного их недостатка — `addEventListener()` позволяет ***назначить более одного обработчика на событие***:

        `<h2 id="testTextField">Тест консоли</h2>`

        `const  testTextField = document.querySelector('#testTextField');
        testTextField.addEventListener('click', 
          (event) => {
            // тело обработчика
            console.log('Это тот блок');
           // конец тела обработчика
        })`

или

       ` document.querySelector('#testTextField').addEventListener('click', 
          (event) => {
            console.log('Это тот блок');
        })`








