[< К содержанию](../readme.md)
***
# события

[Смотреть] выполнение примеров
***

> **Событие** — это сигнал от браузера о том, что что-то произошло.

## Наиболее популярные события:

1. **мышь**:
    * *click* — происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании),
    * *mousemove* — при движении мыши,
    * *contextmenu* — происходит, когда кликнули на элемент правой кнопкой мыши,
    * *mousedown / mouseup* — когда нажали / отжали кнопку мыши на элементе,
    *mouseover / mouseout — когда мышь наводится на / покидает элемент,
2. **элементы управления**:
    * *submit* — пользователь отправил форму `<form>`,
    * *input* — пользователь изменил текст в `<input>`,
3. **клавиатура**:
    * *keydown и keyup* — когда пользователь нажимает / отпускает клавишу,
4. *документ*:
    * *DOMContentLoaded* — когда HTML загружен и обработан,
5. **CSS**:
    * *transitionend* — когда CSS-переход завершён.

## Обработка события

> **Обработчик** — это функция, которая сработает, как только событие произошло. 

> **Назначение обработчика через использование атрибута**

        `<h2 onclick="console.log('Это тот блок')">Тест консоли</h2>`

### Назначение обработчика через свойство**

        <h2 id="testTextField">Тест консоли</h2>

        const  testTextField = document.querySelector('#testTextField');
        testTextField.onclick = function() {
        // тело обработчика
        console.log('Это тот блок');
        // конец тела обработчика
        }

или

        document.querySelector('#testTextField').onclick = function() {
          // тело обработчика
          console.log('Это тот блок');
          // конец тела обработчика
        }

Удалить такой обработчик можно:

        document.querySelector('#testTextField').onclick = null;


> *У этого метода (как и у предыдущего) существует один серьёзный недостаток — нельзя назначить более одного обработчика на событие таким образом. Например, текст в поле ввода проверяется на валидность через один обработчик при событии input, а через другой обработчик — отправляется запрос на сервер. В этом случае, когда назначается на поле ввода второй обработчик, первый затирается.*

### Назначение обработчика через addEventListener**

> Наиболее современный способ назначения обработчика — назначение через метод `addEventListener`.

        `element.addEventListener(event, handler);
        // element - элемент, событие которого отслеживается
        // event - событие
        // handler - обработчик`

Этот способ назначения обработчика наиболее предпочтителен, так как он лишён основного их недостатка — `addEventListener()` позволяет ***назначить более одного обработчика на событие***:

        <h2 id="testTextField">Тест консоли</h2>`

        `const  testTextField = document.querySelector('#testTextField');
        testTextField.addEventListener('click', 
          (event) => {
            // тело обработчика
            console.log('Это тот блок');
           // конец тела обработчика
        })

или

       document.querySelector('#testTextField').addEventListener('click', 
          (event) => {
            console.log('Это тот блок');
        })

### Доступ к элементу через this

Так же [смотри](https://denor74.github.io/WEB-reminder/jscript/this.html) примеры в html

> Внутри метода-обработчика можно получить доступ к элементу, на который назначен обработчик. Делается это через псевдоэлемент `this`: 

        document.querySelector('#testTextField').addEventListener('click', 
          (event) => {
            this.textContent = 'По мне кликнули!';
        })

### Объект события

> **Объект события** — это объект, внутри которого находится различная информация о событии.

Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику. То есть объект события приходит первым аргументом в функцию-обработчик.

> В объекте события могут быть различные данные:

                * *event.type* — тип события (например, ‘click’);
                * *event.target* — элемент, на котором было вызвано событие;
                * *event.target.value* — текущее значение поля ввода, на которое добавлен обработчик события (только для input);
                * *event.currentTarget* — элемент, на котором сработал обработчик;
                * *event.clientX / event.clientY* — координаты курсора в момент клика (относительно окна, для событий мыши).

                document.querySelector('#testTextField').addEventListener('click', 
                 (event) => {
                   this.textContent = 'Это событие: ' + event.type;
                })

### addEventListener-event

> [Смотреть](https://denor74.github.io/WEB-reminder/jscript/event.html) определение координат по клику на тексте в HTML

### Предотвращение поведения по умолчанию

> Пример использования `preventDefault()` для сброса события по умолчанию ссылки (тег `<a>`): 

[Смотреть](preventdefault.html) пример в HTML

                <a href="testTextField" id="testTextField">Кликните по ссылке</a>

                document.querySelector('#testTextField').addEventListener('click', 
                  (event) => {
                    event.preventDefault();
                    alert('Вы кликнули по ссылке и ничего не произошло');
                })

### Всплытие

> При наступлении события обработчики сначала срабатывают на самом элементе, затем на его родителе, затем на родителе родителя и так далее, вверх по цепочке вложенности:

                <div id="parent">
                 <p id="child">
                   Если кликнуть этот текст, то произойдёт три события
                  </p>
                  <p>
                   Если кликнуть этот текст, то произойдет одно событие
                 </p>
                </div>


                document.querySelector('body').addEventListener('click', 
                  (event) => {
                   alert('Событие body');
                })
                document.querySelector('#parent').addEventListener('click', 
                  (event) => {
                    alert('Событие родителя');
                })
                document.querySelector('#child').addEventListener('click', 
                 (event) => {
                   alert('Событие потомка');
                })

> Всплывают не все события. Например, не всплывает событие `focus`.

Если по каким-то причинам требуется остановить всплытие, то используется метод события `stopPropagation()`:

                <div id="parent">
                 <p id="child">
                   Если кликнуть этот текст, то произойдёт три события
                  </p>
                 <p>
                    Если кликнуть этот текст, то произойдет одно событие
                 </p>
                </div>


                document.querySelector('body').addEventListener('click', 
                 (event) => {
                    alert('Событие body');
                })
                document.querySelector('#parent').addEventListener('click', 
                  (event) => {
                    alert('Событие родителя');
                })
                document.querySelector('#child').addEventListener('click', 
                 (event) => {
                    alert('Событие потомка');
                    event.stopPropagation();
                })

> Если на элементе несколько обработчиков, иногда требуется не только перехватить всплытие, но и **прекратить работу остальных обработчиков** для этого элемента. Для этого используется метод `stopImmediatePropagation()`.

> Всплытие — это удобно. Не прекращайте его без **причины**. **Прекращение всплытия** может создавать неожиданные **проблемы**, которые потом приходится обходить. Перед всплытием происходит «погружение»

